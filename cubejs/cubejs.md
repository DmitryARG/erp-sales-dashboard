# Конфигурация сервера Cube.js (cube.js)

## Обзор

Файл `cube.js` настраивает экземпляр сервера Cube.js с PostgreSQL в качестве драйвера базы данных. Он реализует многопользовательскую архитектуру, где данные каждого арендатора логически разделены через контексты безопасности, аутентификацию на основе JWT и динамическую генерацию ID приложения/оркестратора.

## Многопользовательская архитектура

### Механизм изоляции арендаторов

Сервер реализует многопользовательскую архитектуру через следующие ключевые компоненты:

- **Генерация ID приложения**: Функция `contextToAppId` генерирует уникальные ID приложений для каждого арендатора, используя шаблон `CUBEJS_APP_${tenantId}`. Это обеспечивает, что Cube.js поддерживает отдельные кэши запросов и контексты для каждого арендатора.

- **Генерация ID оркестратора**: Аналогично, `contextToOrchestratorId` создает специфические для арендатора ID оркестратора, используя тот же шаблон, позволяя изолированные среды выполнения запросов.

- **Разделение схем базы данных**: При использовании единой базы данных PostgreSQL данные арендатора логически разделены через контроль доступа на основе схем и фильтрацию контекста безопасности.

### Поток контекста арендатора

1. Токены JWT содержат `tenantId` и массивы `userSchemas`
2. `checkAuth` проверяет доступ арендатора по разрешенным схемам
3. Контекст безопасности распространяется через `contextToAppId` и `queryRewrite`
4. Запросы выполняются в контекстах, специфичных для арендатора

## Аутентификация JWT

### Структура токена

Токены JWT содержат:
- `tenantId`: Основной идентификатор арендатора
- `userSchemas`: Массив имен схем, к которым пользователь имеет доступ

### Поток аутентификации

1. **Проверка токена**: Все запросы API требуют токенов Bearer в заголовке Authorization
2. **Функция checkAuth**:
   - Извлекает и проверяет токен JWT
   - Проверяет `tenantId` по разрешенным `userSchemas` пользователя
   - Приоритизирует параметр запроса `tenantId` над JWT `tenantId`
   - Устанавливает `securityContext` на объекте запроса
3. **Механизмы отката**: Множественные попытки установить контекст безопасности в `contextToAppId` и `queryRewrite`

### Функции безопасности

- Истечение срока действия токена (по умолчанию 1 час)
- Контроль доступа на основе схем
- Автоматическая проверка арендатора
- Комплексное логирование для отладки

## Обработка контекста безопасности

### Распространение контекста

Контекст безопасности (`{ tenantId }`) устанавливается и распространяется через несколько слоев:

1. **Начальная настройка**: В `checkAuth` контекст устанавливается на объекте запроса
2. **Контекст приложения**: `contextToAppId` использует контекст безопасности для изоляции приложения
3. **Контекст запроса**: `queryRewrite` обеспечивает выполнение запросов с правильным контекстом арендатора

### Логика отката контекста

Если контекст безопасности недоступен:
1. Проверить `request.securityContext` (установлено `checkAuth`)
2. Декодировать токен JWT из заголовка Authorization
3. Извлечь `tenantId` из декодированного токена

### Логирование и отладка

Расширенное логирование консоли отслеживает:
- Установление контекста безопасности
- Сбои декодирования токена
- Результаты проверки арендатора
- Шаги распространения контекста

## Конечные точки API

### Стандартные конечные точки Cube.js

Cube.js автоматически предоставляет конечные точки REST API для:
- `/cubejs-api/v1/load`: Загрузка данных и запросы
- `/cubejs-api/v1/meta`: Метаданные схемы
- `/cubejs-api/v1/dry-run`: Проверка запросов

### Пользовательские конечные точки

#### POST /login

**Цель**: Аутентифицирует пользователей и генерирует токены JWT

**Тело запроса**:
```json
{
  "login": "string",
  "password": "string"
}
```

**Ответ**:
- Успех (200): `{ "token": "jwt_token", "userSchemas": ["schema1", "schema2"] }`
- Неудача (401): `{ "message": "Invalid credentials" }`
- Ошибка (500): `{ "message": "Internal server error" }`

**Детали реализации**:
- Запрашивает таблицу `users` для учетных данных
- Получает массив `user_schemas`
- Подписывает JWT с `userSchemas` и по умолчанию `tenantId` (первая схема)
- Использует настраиваемый секрет JWT из окружения

## Конфигурация базы данных

### Пул соединений

Использует `pg.Pool` для соединений PostgreSQL с конфигурацией на основе окружения:
- Хост: `CUBEJS_DB_HOST` (по умолчанию: 'db')
- Порт: `CUBEJS_DB_PORT` (по умолчанию: 5432)
- Пользователь: `CUBEJS_DB_USER` (по умолчанию: 'postgres')
- Пароль: `CUBEJS_DB_PASS` (по умолчанию: 'password')
- База данных: `CUBEJS_DB_NAME` (по умолчанию: 'erp')

### Фабрика драйверов

Фабрика драйверов Cube.js создает новые экземпляры драйвера PostgreSQL с идентичными параметрами соединения.

## Конфигурация сервера

### Основные настройки

- **Тип базы данных**: PostgreSQL
- **Путь к схеме**: 'schema' (директория, содержащая файлы схем Cube.js)
- **Драйвер кэша**: Кэширование на основе памяти
- **Запланированное обновление**: Отключено (пустая функция контекстов)

### Логирование

Пользовательская функция логирования выводит все внутренние сообщения Cube.js в консоль с параметрами.

## Переменные окружения

Необходимые переменные окружения:
- `JWT_SECRET`: Секретный ключ для подписывания/проверки JWT (по умолчанию: 'your-secret-key')
- `CUBEJS_DB_HOST`: Хост базы данных
- `CUBEJS_DB_PORT`: Порт базы данных
- `CUBEJS_DB_USER`: Пользователь базы данных
- `CUBEJS_DB_PASS`: Пароль базы данных
- `CUBEJS_DB_NAME`: Имя базы данных

## Соображения безопасности

1. **Безопасность токена**: Токены JWT истекают через 1 час
2. **Контроль доступа**: Пользователи могут получать доступ только к арендаторам в своих `userSchemas`
3. **Изоляция контекста**: Каждый арендатор имеет отдельные контексты приложения и оркестратора
4. **Логирование**: Чувствительная информация логируется (рассмотрите уровни логирования в производстве)

## Влияние на производительность

- Кэширование на основе памяти может не масштабироваться для развертываний с высоким трафиком
- Пул соединений помогает управлять соединениями базы данных
- Контексты, специфичные для арендатора, обеспечивают изоляцию запросов, но могут увеличить использование памяти

## Примечания по развертыванию

Сервер предназначен для запуска в контейнере Docker (как указано по умолчанию хостом 'db'), интегрирован с docker-compose для полного стека панели ERP.